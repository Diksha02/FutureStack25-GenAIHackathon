<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaskPilot - Settings</title>
    <link rel="stylesheet" href="./css/settings.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <div class="logo">
          <span class="logo-icon">üèÜ</span>
          <h1>TaskPilot</h1>
        </div>
        <nav>
          <a href="index.html">Plan</a>
          <a href="today.html">Today</a>
          <a href="tasks.html">Tasks</a>
          <a href="focus.html">Focus</a>
          <a href="settings.html" class="active">Settings</a>
        </nav>
      </header>

      <div class="settings-grid">
        <div class="card">
          <h2>Your Statistics</h2>
          <div class="stats-overview">
            <div class="stat-box">
              <div class="stat-value" id="totalSessions">0</div>
              <div class="stat-label">Total Sessions</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="totalFocusTime">0h</div>
              <div class="stat-label">Total Focus Time</div>
            </div>
            <div class="stat-box">
              <div class="stat-value" id="totalTasks">0</div>
              <div class="stat-label">Tasks Completed</div>
            </div>
          </div>
          <button class="btn-secondary" onclick="resetStats()">
            <span>‚Ü∫</span>
            <span>Reset Statistics</span>
          </button>
        </div>

        <!-- <div class="card">
          <h2>General Settings</h2>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Timezone</div>
              <div class="setting-description">
                Set your local timezone for accurate scheduling
              </div>
            </div>
            <div class="setting-control">
              <select id="timezone">
                <option value="UTC">UTC</option>
                <option value="America/New_York">Eastern Time</option>
                <option value="America/Chicago">Central Time</option>
                <option value="America/Denver">Mountain Time</option>
                <option value="America/Los_Angeles">Pacific Time</option>
                <option value="Europe/London">London</option>
                <option value="Europe/Paris">Paris</option>
                <option value="Asia/Tokyo">Tokyo</option>
                <option value="Asia/Kolkata">India</option>
              </select>
            </div>
          </div>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Theme</div>
              <div class="setting-description">
                Choose your preferred color theme
              </div>
            </div>
            <div class="setting-control">
              <select id="theme">
                <option value="default">Default Purple</option>
                <option value="blue">Ocean Blue</option>
                <option value="green">Forest Green</option>
                <option value="orange">Sunset Orange</option>
              </select>
            </div>
          </div>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Notifications</div>
              <div class="setting-description">
                Enable browser notifications for task reminders
              </div>
            </div>
            <div class="setting-control">
              <label class="toggle-switch">
                <input type="checkbox" id="notifications" checked />
                <span class="slider"></span>
              </label>
            </div>
          </div>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Sound Effects</div>
              <div class="setting-description">
                Play sounds when timer completes
              </div>
            </div>
            <div class="setting-control">
              <label class="toggle-switch">
                <input type="checkbox" id="sounds" checked />
                <span class="slider"></span>
              </label>
            </div>
          </div>
        </div> -->

        <div class="card">
          <h2>Focus Settings</h2>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Default Focus Duration</div>
              <div class="setting-description">
                Default length for focus sessions (minutes)
              </div>
            </div>
            <div class="setting-control">
              <input
                type="number"
                id="focusDuration"
                value="25"
                min="5"
                max="120"
              />
            </div>
          </div>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Break Duration</div>
              <div class="setting-description">
                Length of breaks between sessions (minutes)
              </div>
            </div>
            <div class="setting-control">
              <input
                type="number"
                id="breakDuration"
                value="5"
                min="1"
                max="30"
              />
            </div>
          </div>

          <!-- <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Auto-start Breaks</div>
              <div class="setting-description">
                Automatically start break timer after focus session
              </div>
            </div>
            <div class="setting-control">
              <label class="toggle-switch">
                <input type="checkbox" id="autoBreak" />
                <span class="slider"></span>
              </label>
            </div>
          </div> -->
        </div>

        <div class="card">
          <h2>AI Model Settings</h2>
          <p style="color: #718096; margin-bottom: 20px">
            Choose which Cerebras model to use for AI plan generation. Faster
            models generate plans quickly but may be less detailed, while larger
            models provide higher quality at the cost of speed.
          </p>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">AI Model</div>
              <div class="setting-description">
                Select the Cerebras Llama model for plan generation
              </div>
            </div>
            <div class="setting-control">
              <select id="aiModel" onchange="handleModelChange()">
                <option value="">Loading models...</option>
              </select>
            </div>
          </div>

          <div
            id="modelInfo"
            style="
              margin-top: 20px;
              padding: 15px;
              background: #f7fafc;
              border-radius: 8px;
              display: none;
            "
          >
            <h3 style="margin: 0 0 10px 0; font-size: 16px">
              Model Information
            </h3>
            <div
              style="
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                font-size: 14px;
              "
            >
              <div><strong>Speed:</strong> <span id="modelSpeed">-</span></div>
              <div>
                <strong>Quality:</strong> <span id="modelQuality">-</span>
              </div>
              <div>
                <strong>Tokens/sec:</strong> <span id="modelTokens">-</span>
              </div>
              <div>
                <strong>Best for:</strong> <span id="modelBestFor">-</span>
              </div>
            </div>
            <p
              style="margin: 10px 0 0 0; color: #4a5568"
              id="modelDescription"
            ></p>
          </div>

          <div
            id="modelMetrics"
            style="
              margin-top: 15px;
              padding: 15px;
              background: #edf2f7;
              border-radius: 8px;
              display: none;
            "
          >
            <h3 style="margin: 0 0 10px 0; font-size: 16px">
              Last Generation Metrics
            </h3>
            <div
              style="
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                font-size: 14px;
              "
            >
              <div>
                <strong>Latency:</strong> <span id="metricLatency">-</span>
              </div>
              <div>
                <strong>Tokens Used:</strong> <span id="metricTokens">-</span>
              </div>
              <div><strong>Model:</strong> <span id="metricModel">-</span></div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Data Management</h2>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Export Data</div>
              <div class="setting-description">
                Download all your tasks and settings as JSON
              </div>
            </div>
            <div class="setting-control">
              <button class="btn-primary" onclick="exportData()">
                <span>Export</span>
              </button>
            </div>
          </div>

          <div class="setting-item">
            <div class="setting-info">
              <div class="setting-label">Import Data</div>
              <div class="setting-description">
                Restore tasks and settings from JSON file
              </div>
            </div>
            <div class="setting-control">
              <input
                type="file"
                id="importFile"
                accept=".json"
                style="display: none"
                onchange="importData()"
              />
              <button
                class="btn-primary"
                onclick="document.getElementById('importFile').click()"
              >
                <span>Import</span>
              </button>
            </div>
          </div>

          <div class="danger-zone">
            <h3>Danger Zone</h3>
            <p style="margin-bottom: 15px; color: #742a2a">
              These actions cannot be undone.
            </p>
            <div class="button-group">
              <button class="btn-danger" onclick="clearAllData()">
                <span>Clear All Data</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="alert alert-success" id="successAlert">
        ‚úÖ Settings saved successfully!
      </div>

      <div class="alert alert-error" id="errorAlert">
        ‚ùå An error occurred. Please try again.
      </div>
    </div>

    <script>
      function loadSettings() {
        // Load statistics
        const stats = JSON.parse(
          localStorage.getItem("focusStats") ||
            '{"sessionsToday": 0, "totalFocusTime": 0, "currentStreak": 0}'
        );
        const completedTasks = JSON.parse(
          localStorage.getItem("completedTasks") || "[]"
        );

        document.getElementById("totalSessions").textContent =
          stats.sessionsToday;
        document.getElementById("totalFocusTime").textContent =
          Math.round(stats.totalFocusTime / 3600) + "h";
        document.getElementById("totalTasks").textContent =
          completedTasks.length;

        // Load settings
        const settings = JSON.parse(localStorage.getItem("settings") || "{}");

        // Only set values for elements that exist
        const timezone = document.getElementById("timezone");
        if (timezone && settings.timezone) timezone.value = settings.timezone;

        const theme = document.getElementById("theme");
        if (theme && settings.theme) theme.value = settings.theme;

        const focusDuration = document.getElementById("focusDuration");
        if (focusDuration && settings.focusDuration)
          focusDuration.value = settings.focusDuration;

        const breakDuration = document.getElementById("breakDuration");
        if (breakDuration && settings.breakDuration)
          breakDuration.value = settings.breakDuration;

        const notifications = document.getElementById("notifications");
        if (notifications)
          notifications.checked = settings.notifications !== false;

        const sounds = document.getElementById("sounds");
        if (sounds) sounds.checked = settings.sounds !== false;

        const autoBreak = document.getElementById("autoBreak");
        if (autoBreak) autoBreak.checked = settings.autoBreak === true;
      }

      function saveSettings() {
        const settings = {};

        const timezone = document.getElementById("timezone");
        if (timezone) settings.timezone = timezone.value;

        const theme = document.getElementById("theme");
        if (theme) settings.theme = theme.value;

        const notifications = document.getElementById("notifications");
        if (notifications) settings.notifications = notifications.checked;

        const sounds = document.getElementById("sounds");
        if (sounds) settings.sounds = sounds.checked;

        const focusDuration = document.getElementById("focusDuration");
        if (focusDuration)
          settings.focusDuration = parseInt(focusDuration.value);

        const breakDuration = document.getElementById("breakDuration");
        if (breakDuration)
          settings.breakDuration = parseInt(breakDuration.value);

        const autoBreak = document.getElementById("autoBreak");
        if (autoBreak) settings.autoBreak = autoBreak.checked;

        localStorage.setItem("settings", JSON.stringify(settings));
        showAlert("success");
      }

      // Request browser notification permission when toggled on
      function handleNotificationToggle(e) {
        const enabled = e.target.checked;
        if (enabled && "Notification" in window) {
          try {
            if (Notification.permission === "default") {
              Notification.requestPermission().then((perm) => {
                if (perm !== "granted") {
                  // Revert toggle if not granted
                  e.target.checked = false;
                }
                saveSettings();
              });
              return;
            }
          } catch (_) {}
        }
        saveSettings();
      }

      // Play a short preview when enabling sounds
      function handleSoundToggle(e) {
        const enabled = e.target.checked;
        saveSettings();
        if (enabled) {
          try {
            const audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = 880;
            oscillator.type = "sine";
            gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              audioContext.currentTime + 0.25
            );
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.25);
          } catch (_) {}
        }
      }

      function resetStats() {
        if (
          confirm(
            "Are you sure you want to reset all statistics? This cannot be undone."
          )
        ) {
          localStorage.setItem(
            "focusStats",
            JSON.stringify({
              sessionsToday: 0,
              totalFocusTime: 0,
              currentStreak: 0,
            })
          );
          loadSettings();
          showAlert("success");
        }
      }

      async function exportData() {
        try {
          console.log("Starting export...");
          console.log("Fetching from: /export-schedules");

          // Fetch all schedules from backend
          const response = await fetch("/export-schedules");
          console.log("Response status:", response.status);
          console.log("Response headers:", [...response.headers.entries()]);

          if (!response.ok) {
            const errorText = await response.text();
            console.error("Export failed with status:", response.status);
            console.error("Error response:", errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }

          const data = await response.json();
          console.log("Export data received:", data);
          console.log(`Total schedules: ${data.totalSchedules}`);

          // Create downloadable file
          const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `taskpilot-backup-${
            new Date().toISOString().split("T")[0]
          }.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showAlert("success");
          alert(`Exported ${data.totalSchedules} schedule(s) successfully!`);
          console.log(
            `Export completed successfully - ${data.totalSchedules} schedules`
          );
        } catch (error) {
          console.error("Export failed:", error);
          console.error("Error details:", error.stack);
          console.error("Error message:", error.message);
          alert(
            `Export failed: ${error.message}\n\nCheck console for details.`
          );
          showAlert("error");
        }
      }

      async function importData() {
        const file = document.getElementById("importFile").files[0];
        if (!file) return;

        console.log("Starting import...");
        console.log("File name:", file.name);
        console.log("File size:", file.size, "bytes");

        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            console.log("File loaded, parsing JSON...");
            const data = JSON.parse(e.target.result);
            console.log("Parsed data:", data);

            // Validate data format
            if (!data.schedules || !Array.isArray(data.schedules)) {
              console.error("Invalid data format:", data);
              alert(
                "Invalid backup file format. Expected a TaskPilot backup with schedules array."
              );
              showAlert("error");
              return;
            }

            console.log(
              `Valid backup file with ${data.schedules.length} schedules`
            );
            console.log("Export date:", data.exportDate || "Unknown");

            // Confirm import
            const confirmMsg = `Found ${
              data.schedules.length
            } schedule(s) in backup file.\n\nImport date: ${
              data.exportDate || "Unknown"
            }\n\nThis will ADD these schedules to your existing data. Continue?`;
            if (!confirm(confirmMsg)) {
              console.log("Import cancelled by user");
              return;
            }

            console.log("Sending to backend: /import-schedules");
            // Send to backend
            const response = await fetch("/import-schedules", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                schedules: data.schedules,
                replaceExisting: false,
              }),
            });

            console.log("Response status:", response.status);
            console.log("Response headers:", [...response.headers.entries()]);

            if (!response.ok) {
              const errorText = await response.text();
              console.error("Import failed with status:", response.status);
              console.error("Error response:", errorText);
              throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            console.log("Import response:", result);

            if (result.success) {
              console.log(
                `Import successful - Imported: ${result.imported}, Skipped: ${result.skipped}`
              );
              alert(
                `${result.message}\n\nImported: ${result.imported}\nSkipped: ${result.skipped}`
              );
              showAlert("success");
            } else {
              throw new Error(result.error || "Import failed");
            }
          } catch (error) {
            console.error("Import failed:", error);
            console.error("Error details:", error.stack);
            console.error("Error message:", error.message);
            alert("Failed to import data: " + error.message);
            showAlert("error");
          }
        };
        reader.readAsText(file);
      }

      // Model management
      let availableModels = [];
      let currentModelData = null;

      async function loadModels() {
        try {
          const response = await fetch("/api/models");
          const data = await response.json();

          if (data.success) {
            availableModels = data.models;
            const currentModel = data.currentModel;

            // Populate dropdown
            const select = document.getElementById("aiModel");
            select.innerHTML = "";

            availableModels.forEach((model) => {
              const option = document.createElement("option");
              option.value = model.id;
              option.textContent = model.name;
              if (model.id === currentModel) {
                option.selected = true;
                updateModelInfo(model);
              }
              select.appendChild(option);
            });
          }
        } catch (error) {
          console.error("Failed to load models:", error);
          document.getElementById("aiModel").innerHTML =
            '<option value="">Error loading models</option>';
        }
      }

      function updateModelInfo(model) {
        currentModelData = model;
        document.getElementById("modelSpeed").textContent = model.speed;
        document.getElementById("modelQuality").textContent = model.quality;
        document.getElementById("modelTokens").textContent =
          model.tokensPerSecond;
        document.getElementById("modelBestFor").textContent = model.bestFor;
        document.getElementById("modelDescription").textContent =
          model.description;
        document.getElementById("modelInfo").style.display = "block";
      }

      async function handleModelChange() {
        const select = document.getElementById("aiModel");
        const modelId = select.value;

        if (!modelId) return;

        const model = availableModels.find((m) => m.id === modelId);
        if (!model) return;

        try {
          const response = await fetch("/api/models/set", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ modelId }),
          });

          const data = await response.json();

          if (data.success) {
            updateModelInfo(model);
            alert(
              `Model switched to ${model.name}!\n\nSpeed: ${model.speed}\nQuality: ${model.quality}`
            );
            console.log("Model changed:", data);
          } else {
            alert("Failed to change model: " + data.error);
          }
        } catch (error) {
          console.error("Error changing model:", error);
          alert("Failed to change model. Please try again.");
        }
      }

      function clearAllData() {
        if (
          confirm(
            "‚ö†Ô∏è WARNING: This will delete ALL your data including tasks, statistics, and settings. This cannot be undone. Are you absolutely sure?"
          )
        ) {
          if (
            confirm("Last chance! Click OK to permanently delete everything.")
          ) {
            localStorage.clear();
            loadSettings();
            showAlert("success");
            setTimeout(() => location.reload(), 1500);
          }
        }
      }

      function showAlert(type) {
        const alert = document.getElementById(type + "Alert");
        alert.classList.add("show");
        setTimeout(() => {
          alert.classList.remove("show");
        }, 3000);
      }

      // Auto-save settings on change
      document
        .querySelectorAll(
          'select, input[type="checkbox"], input[type="number"]'
        )
        .forEach((element) => {
          if (element.id === "aiModel") {
            // Model changes handled by handleModelChange()
            return;
          } else if (element.id === "notifications") {
            element.addEventListener("change", handleNotificationToggle);
          } else if (element.id === "sounds") {
            element.addEventListener("change", handleSoundToggle);
          } else {
            element.addEventListener("change", saveSettings);
          }
        });

      // Load last generation metrics
      function loadLastMetrics() {
        const metricsStr = localStorage.getItem("lastGenMetrics");
        if (metricsStr) {
          try {
            const metrics = JSON.parse(metricsStr);
            document.getElementById("metricLatency").textContent =
              metrics.latency ? `${metrics.latency}ms` : "-";
            document.getElementById("metricTokens").textContent =
              metrics.tokensUsed ? JSON.stringify(metrics.tokensUsed) : "-";
            document.getElementById("metricModel").textContent =
              metrics.model || "-";
            document.getElementById("modelMetrics").style.display = "block";
          } catch (e) {
            console.error("Error loading metrics:", e);
          }
        }
      }

      // Load settings and models on page load
      loadSettings();
      loadModels();
      loadLastMetrics();
    </script>
  </body>
</html>
