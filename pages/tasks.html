<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaskPilot - Tasks</title>
    <link rel="stylesheet" href="./css/tasks.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <div class="logo">
          <span class="logo-icon">üèÜ</span>
          <h1>TaskPilot</h1>
        </div>
        <nav>
          <a href="index.html">Plan</a>
          <a href="today.html">Today</a>
          <a href="tasks.html" class="active">Tasks</a>
          <a href="focus.html">Focus</a>
          <a href="settings.html">Settings</a>
        </nav>
      </header>

      <div class="card">
        <h2>Task Manager</h2>

        <div class="stats-bar" id="statsBar"></div>

        <div class="toolbar">
          <div class="filter-group">
            <button class="filter-btn active" onclick="filterTasks('all')">
              All
            </button>
            <button class="filter-btn" onclick="filterTasks('active')">
              Active
            </button>
            <button class="filter-btn" onclick="filterTasks('completed')">
              Completed
            </button>
            <button class="filter-btn" onclick="filterTasks('high')">
              High Priority
            </button>
          </div>
          <div class="search-box">
            <button
              class="btn-primary"
              onclick="addNewTask()"
              style="
                margin-right: 10px;
                padding: 8px 16px;
                background: #5568d3;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 500;
              "
            >
              ‚ûï Add New Task
            </button>
            <input
              type="text"
              id="searchInput"
              placeholder="Search tasks..."
              oninput="searchTasks()"
            />
            <button
              class="filter-btn"
              onclick="loadTasks()"
              title="Refresh from database"
            >
              üîÑ Refresh
            </button>
          </div>
        </div>

        <div class="task-grid" id="taskGrid"></div>
      </div>
    </div>

    <div class="modal" id="editModal">
      <div class="modal-content">
        <h3 id="modalTitle">‚úèÔ∏è Edit Task</h3>
        <div class="form-group">
          <label>Task Name</label>
          <input type="text" id="editTaskName" placeholder="Enter task name" />
        </div>
        <div class="form-group">
          <label>Time</label>
          <input type="time" id="editTaskTime" />
        </div>
        <div class="form-group">
          <label>Duration (minutes)</label>
          <input type="number" id="editTaskDuration" placeholder="60" min="1" />
        </div>
        <div class="form-group">
          <label>Priority</label>
          <select id="editTaskPriority">
            <option value="high">High</option>
            <option value="medium">Medium</option>
            <option value="low">Low</option>
          </select>
        </div>
        <div class="modal-actions">
          <button class="btn-secondary" onclick="closeEditModal()">
            Cancel
          </button>
          <button class="btn-primary" onclick="saveTask()">Save</button>
        </div>
      </div>
    </div>

    <script>
      let tasks = [];
      let completedTasks = new Set();
      let currentFilter = "all";
      let editingIndex = -1;
      let currentScheduleId = null; // Track the current schedule ID for updates

      async function loadTasks() {
        try {
          // Fetch today's schedule from backend with cache-busting
          const response = await fetch(`/schedules/today?_=${Date.now()}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.schedule) {
              tasks = data.schedule;
              currentScheduleId = data.scheduleId; // Store the schedule ID
              console.log(
                `‚úÖ Loaded ${tasks.length} tasks from backend (ID: ${currentScheduleId})`
              );

              // Load completion status from tasks if stored
              completedTasks = new Set();
              tasks.forEach((task, index) => {
                if (task.completed) {
                  completedTasks.add(index);
                }
              });
            } else {
              console.log("No schedule found for today");
              tasks = [];
              currentScheduleId = null;
            }
          } else if (response.status === 404) {
            console.log("No schedule saved for today yet");
            tasks = [];
            currentScheduleId = null;
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          console.error("Failed to load tasks from backend:", error);
          // Fallback to localStorage if backend fails
          const saved = localStorage.getItem("todaySchedule");
          if (saved) {
            tasks = JSON.parse(saved);
            console.log("‚ö†Ô∏è Using localStorage fallback");
          } else {
            tasks = [];
          }
        }

        // Load completed state from localStorage (per-session data)
        const savedCompleted = localStorage.getItem("completedTasks");
        if (savedCompleted) {
          completedTasks = new Set(JSON.parse(savedCompleted));
        }

        // Sort tasks by time (chronologically)
        tasks.sort((a, b) => {
          const timeA = timeToMinutes(a.time);
          const timeB = timeToMinutes(b.time);
          return timeA - timeB;
        });

        renderTasks();
        renderStats();
      }

      // Save updated tasks to backend
      async function saveTasksToBackend() {
        if (!currentScheduleId) {
          console.warn("No schedule ID available, cannot save to backend");
          return;
        }

        try {
          // Update completion status in tasks array
          const updatedTasks = tasks.map((task, index) => ({
            ...task,
            completed: completedTasks.has(index),
          }));

          const response = await fetch(`/schedules/${currentScheduleId}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ plan: updatedTasks }),
          });

          if (response.ok) {
            console.log("‚úÖ Tasks saved to backend");
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          console.error("Failed to save tasks to backend:", error);
        }
      }

      function renderStats() {
        const total = tasks.length;
        const completed = completedTasks.size;
        const active = total - completed;
        const highPriority = tasks.filter((t) => t.priority === "high").length;

        document.getElementById("statsBar").innerHTML = `
                <div class="stat-box">
                    <div class="stat-value">${total}</div>
                    <div class="stat-label">Total Tasks</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${active}</div>
                    <div class="stat-label">Active</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${completed}</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value">${highPriority}</div>
                    <div class="stat-label">High Priority</div>
                </div>
            `;
      }

      function renderTasks() {
        const grid = document.getElementById("taskGrid");
        const searchTerm = document
          .getElementById("searchInput")
          .value.toLowerCase();

        let filteredTasks = tasks.map((task, index) => ({ ...task, index }));

        // Apply filters
        if (currentFilter === "active") {
          filteredTasks = filteredTasks.filter(
            (t) => !completedTasks.has(t.index)
          );
        } else if (currentFilter === "completed") {
          filteredTasks = filteredTasks.filter((t) =>
            completedTasks.has(t.index)
          );
        } else if (currentFilter === "high") {
          filteredTasks = filteredTasks.filter((t) => t.priority === "high");
        }

        // Apply search
        if (searchTerm) {
          filteredTasks = filteredTasks.filter((t) =>
            t.task.toLowerCase().includes(searchTerm)
          );
        }

        if (filteredTasks.length === 0) {
          grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <p>No tasks found</p>
                    </div>
                `;
          return;
        }

        grid.innerHTML = filteredTasks
          .map(
            (task) => `
                <div class="task-card ${
                  completedTasks.has(task.index) ? "completed" : ""
                }">
                    <div class="checkbox ${
                      completedTasks.has(task.index) ? "checked" : ""
                    }" 
                         onclick="toggleTask(${task.index})">
                        ${completedTasks.has(task.index) ? "‚úì" : ""}
                    </div>
                    <div class="task-content">
                        <div class="task-title">${task.task}</div>
                        <div class="task-meta">
                            <span>‚è∞ ${getTimeRange(task)}</span>
                            <span>‚è±Ô∏è ${task.duration}</span>
                            <span class="priority-badge priority-${
                              task.priority
                            }">${task.priority}</span>
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="icon-btn" onclick="editTask(${
                          task.index
                        })" title="Edit">
                            ‚úèÔ∏è
                        </button>
                        <button class="icon-btn" onclick="deleteTask(${
                          task.index
                        })" title="Delete">
                            üóëÔ∏è
                        </button>
                    </div>
                </div>
            `
          )
          .join("");
      }

      async function toggleTask(index) {
        if (completedTasks.has(index)) {
          completedTasks.delete(index);
        } else {
          completedTasks.add(index);
        }
        localStorage.setItem(
          "completedTasks",
          JSON.stringify([...completedTasks])
        );
        renderTasks();
        renderStats();

        // Save to backend
        await saveTasksToBackend();
      }

      function filterTasks(filter) {
        currentFilter = filter;
        document
          .querySelectorAll(".filter-btn")
          .forEach((btn) => btn.classList.remove("active"));
        event.target.classList.add("active");
        renderTasks();
      }

      function searchTasks() {
        renderTasks();
      }

      function addNewTask() {
        editingIndex = -1; // -1 indicates we're adding a new task
        document.getElementById("modalTitle").textContent = "‚ûï Add New Task";

        // Clear all fields
        document.getElementById("editTaskName").value = "";
        document.getElementById("editTaskTime").value = "";
        document.getElementById("editTaskDuration").value = "60";
        document.getElementById("editTaskPriority").value = "medium";

        document.getElementById("editModal").classList.add("active");
      }

      function editTask(index) {
        editingIndex = index;
        document.getElementById("modalTitle").textContent = "‚úèÔ∏è Edit Task";
        const task = tasks[index];
        document.getElementById("editTaskName").value = task.task;
        document.getElementById("editTaskTime").value = task.time;
        document.getElementById("editTaskDuration").value = parseInt(
          task.duration
        );
        document.getElementById("editTaskPriority").value = task.priority;
        document.getElementById("editModal").classList.add("active");
      }

      function closeEditModal() {
        document.getElementById("editModal").classList.remove("active");
        editingIndex = -1;
      }

      // Helper: convert minutes to "HH:MM AM/PM" format
      const minutesToTimeString = (minutes) => {
        let hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        const ampm = hours >= 12 ? "PM" : "AM";
        if (hours > 12) hours -= 12;
        if (hours === 0) hours = 12;
        return `${String(hours).padStart(2, "0")}:${String(mins).padStart(
          2,
          "0"
        )} ${ampm}`;
      };

      // Helper: get time range string for a task
      const getTimeRange = (task) => {
        if (task.timeRange) return task.timeRange; // Already has full range
        if (task.time && task.durationMinutes) {
          const startMinutes = timeToMinutes(task.time);
          if (!isNaN(startMinutes)) {
            const endMinutes = startMinutes + task.durationMinutes;
            const endTime = minutesToTimeString(endMinutes);
            return `${task.time} - ${endTime}`;
          }
        }
        return task.time || "";
      };

      // Helper function to convert time string (HH:MM or HH:MM AM/PM) to minutes since midnight
      function timeToMinutes(timeStr) {
        if (!timeStr) return 0;

        // Handle 24-hour format (HH:MM)
        if (
          timeStr.includes(":") &&
          !timeStr.includes("AM") &&
          !timeStr.includes("PM")
        ) {
          const [hours, minutes] = timeStr.split(":").map(Number);
          return hours * 60 + minutes;
        }

        // Handle 12-hour format (HH:MM AM/PM)
        const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
        if (!match) return 0;

        let hours = parseInt(match[1]);
        const minutes = parseInt(match[2]);
        const period = match[3]?.toUpperCase();

        if (period === "PM" && hours !== 12) hours += 12;
        if (period === "AM" && hours === 12) hours = 0;

        return hours * 60 + minutes;
      }

      // Helper function to convert minutes to HH:MM format
      function minutesToTime(minutes) {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return `${String(hours).padStart(2, "0")}:${String(mins).padStart(
          2,
          "0"
        )}`;
      }

      // Check if two time ranges overlap
      function hasTimeConflict(start1, duration1, start2, duration2) {
        const end1 = start1 + duration1;
        const end2 = start2 + duration2;

        // Check if ranges overlap
        return start1 < end2 && end1 > start2;
      }

      // Get priority weight for sorting (higher = more important)
      function getPriorityWeight(priority) {
        const weights = { high: 3, medium: 2, low: 1 };
        return weights[priority] || 2;
      }

      // Recursively adjust overlapping tasks with cascading conflict resolution
      function adjustOverlappingTasks(
        newTaskTime,
        newTaskDuration,
        newTaskPriority,
        excludeIndex = -1
      ) {
        const newTaskStart = timeToMinutes(newTaskTime);
        const newTaskEnd = newTaskStart + newTaskDuration;
        const newTaskWeight = getPriorityWeight(newTaskPriority);

        let allAdjustments = [];
        let hasHigherPriorityConflict = false;

        // Find all conflicting tasks
        let conflicts = [];
        tasks.forEach((task, index) => {
          if (index === excludeIndex) return; // Skip the task being edited

          const taskStart = timeToMinutes(task.time);
          const taskDuration = task.durationMinutes || 60;

          if (
            hasTimeConflict(
              newTaskStart,
              newTaskDuration,
              taskStart,
              taskDuration
            )
          ) {
            const taskWeight = getPriorityWeight(task.priority);

            // Check if conflicting task has higher priority
            if (taskWeight > newTaskWeight) {
              hasHigherPriorityConflict = true;
            }

            conflicts.push({
              index,
              task,
              start: taskStart,
              duration: taskDuration,
              priority: task.priority,
              weight: taskWeight,
            });
          }
        });

        // If there's a higher priority conflict, prevent the operation
        if (hasHigherPriorityConflict) {
          return {
            success: false,
            reason: "higher_priority_conflict",
            conflicts,
          };
        }

        // Sort conflicts by start time (earliest first)
        conflicts.sort((a, b) => a.start - b.start);

        // Recursively adjust conflicting tasks
        let nextAvailableTime = newTaskEnd;

        for (const conflict of conflicts) {
          // Move conflicting task to next available slot
          const adjustedStart = nextAvailableTime;
          const adjustedTime = minutesToTime(adjustedStart);

          allAdjustments.push({
            index: conflict.index,
            taskName: conflict.task.task,
            oldTime: conflict.task.time,
            newTime: adjustedTime,
          });

          // Update the task time
          tasks[conflict.index].time = adjustedTime;

          // Check if this moved task now conflicts with others (cascading)
          const cascadingResult = checkAndResolveChain(
            adjustedStart,
            conflict.duration,
            conflict.task.priority,
            conflict.index,
            nextAvailableTime + conflict.duration
          );

          if (!cascadingResult.success) {
            return cascadingResult; // Propagate failure up
          }

          allAdjustments.push(...cascadingResult.adjustments);

          // Update next available time
          nextAvailableTime = cascadingResult.nextTime;
        }

        return { success: true, adjustments: allAdjustments };
      }

      // Check and resolve cascading conflicts
      function checkAndResolveChain(
        movedTaskStart,
        movedTaskDuration,
        movedTaskPriority,
        movedTaskIndex,
        currentEndTime
      ) {
        const movedTaskEnd = movedTaskStart + movedTaskDuration;
        const movedTaskWeight = getPriorityWeight(movedTaskPriority);

        let adjustments = [];
        let nextTime = currentEndTime;

        // Find tasks that now conflict with the moved task
        let newConflicts = [];
        tasks.forEach((task, index) => {
          if (index === movedTaskIndex) return; // Skip self

          const taskStart = timeToMinutes(task.time);
          const taskDuration = task.durationMinutes || 60;

          if (
            hasTimeConflict(
              movedTaskStart,
              movedTaskDuration,
              taskStart,
              taskDuration
            )
          ) {
            const taskWeight = getPriorityWeight(task.priority);

            // Can't move higher priority tasks
            if (taskWeight > movedTaskWeight) {
              return {
                success: false,
                reason: "cascading_higher_priority_conflict",
                conflicts: [{ task, index }],
              };
            }

            newConflicts.push({
              index,
              task,
              start: taskStart,
              duration: taskDuration,
              priority: task.priority,
            });
          }
        });

        // Sort by start time
        newConflicts.sort((a, b) => a.start - b.start);

        // Recursively move each conflicting task
        for (const conflict of newConflicts) {
          const adjustedStart = nextTime;
          const adjustedTime = minutesToTime(adjustedStart);

          adjustments.push({
            index: conflict.index,
            taskName: conflict.task.task,
            oldTime: conflict.task.time,
            newTime: adjustedTime,
          });

          tasks[conflict.index].time = adjustedTime;
          nextTime = adjustedStart + conflict.duration;
        }

        return { success: true, adjustments, nextTime };
      }

      async function saveTask() {
        // Validate required fields
        const taskName = document.getElementById("editTaskName").value.trim();
        const taskTime = document.getElementById("editTaskTime").value;
        const taskDuration = document.getElementById("editTaskDuration").value;

        if (!taskName) {
          alert("Please enter a task name");
          return;
        }

        if (!taskTime) {
          alert("Please select a time");
          return;
        }

        if (!taskDuration || parseInt(taskDuration) <= 0) {
          alert("Please enter a valid duration");
          return;
        }

        const newTaskPriority =
          document.getElementById("editTaskPriority").value;

        const newTask = {
          task: taskName,
          time: taskTime,
          duration: taskDuration + " min",
          durationMinutes: parseInt(taskDuration),
          priority: newTaskPriority,
          completed: false,
        };

        // Check for time conflicts and adjust overlapping tasks
        const result = adjustOverlappingTasks(
          taskTime,
          parseInt(taskDuration),
          newTaskPriority,
          editingIndex // Exclude current task if editing
        );

        // Handle priority conflicts - BLOCK the operation
        if (!result.success) {
          let errorMessage = "";

          if (result.reason === "higher_priority_conflict") {
            const conflictDetails = result.conflicts
              .map(
                (c) =>
                  `‚Ä¢ ${c.task.task} (${c.priority} priority) at ${c.task.time}`
              )
              .join("\n");

            errorMessage = `‚ùå Cannot add/edit task!\n\nThis time slot conflicts with higher priority tasks:\n\n${conflictDetails}\n\nPlease either:\n‚Ä¢ Choose a different time\n‚Ä¢ Increase this task's priority to High\n‚Ä¢ Manually reschedule the conflicting tasks`;
          } else if (result.reason === "cascading_higher_priority_conflict") {
            errorMessage = `‚ùå Cannot resolve conflicts!\n\nMoving conflicting tasks would affect other high-priority tasks.\n\nPlease choose a different time slot or manually adjust your schedule.`;
          }

          // Show error modal
          alert(errorMessage);
          return; // ABORT - don't save the task
        }

        // Success - apply changes
        if (editingIndex >= 0) {
          // EDIT MODE: Update existing task
          const wasCompleted = tasks[editingIndex].completed;
          tasks[editingIndex] = {
            ...newTask,
            completed: wasCompleted, // Preserve completion status
          };
        } else {
          // ADD MODE: Add new task
          tasks.push(newTask);
        }

        // Sort tasks by time (chronologically)
        tasks.sort((a, b) => {
          const timeA = timeToMinutes(a.time);
          const timeB = timeToMinutes(b.time);
          return timeA - timeB;
        });

        localStorage.setItem("todaySchedule", JSON.stringify(tasks));
        closeEditModal();
        renderTasks();
        renderStats();

        // Save to backend
        await saveTasksToBackend();

        // Show success message with conflict info
        const successMsg = document.createElement("div");
        successMsg.style.cssText =
          "position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 9999; animation: slideIn 0.3s ease; max-width: 400px; font-size: 14px; line-height: 1.5;";

        let message =
          editingIndex >= 0
            ? "‚úì Task updated successfully"
            : "‚úì Task added successfully";

        if (result.adjustments && result.adjustments.length > 0) {
          const uniqueTasks = new Set(result.adjustments.map((a) => a.index))
            .size;
          message += `\n\n‚ö†Ô∏è ${uniqueTasks} task${
            uniqueTasks > 1 ? "s" : ""
          } automatically rescheduled:`;

          // Show first 3 adjustments
          const displayAdjustments = result.adjustments.slice(0, 3);
          displayAdjustments.forEach((adj) => {
            message += `\n‚Ä¢ ${adj.taskName}: ${adj.oldTime} ‚Üí ${adj.newTime}`;
          });

          if (result.adjustments.length > 3) {
            message += `\n‚Ä¢ ... and ${result.adjustments.length - 3} more`;
          }
        }

        successMsg.style.whiteSpace = "pre-line";
        successMsg.textContent = message;
        document.body.appendChild(successMsg);
        setTimeout(
          () => {
            successMsg.style.opacity = "0";
            successMsg.style.transition = "opacity 0.3s";
            setTimeout(() => document.body.removeChild(successMsg), 300);
          },
          result.adjustments && result.adjustments.length > 0 ? 4500 : 2000
        ); // Show longer if conflicts were resolved
      }

      async function deleteTask(index) {
        if (confirm("Are you sure you want to delete this task?")) {
          tasks.splice(index, 1);
          completedTasks.delete(index);
          // Reindex completed tasks
          const newCompleted = new Set();
          completedTasks.forEach((i) => {
            if (i < index) newCompleted.add(i);
            else if (i > index) newCompleted.add(i - 1);
          });
          completedTasks = newCompleted;
          localStorage.setItem("todaySchedule", JSON.stringify(tasks));
          localStorage.setItem(
            "completedTasks",
            JSON.stringify([...completedTasks])
          );
          renderTasks();
          renderStats();

          // Save to backend
          await saveTasksToBackend();
        }
      }

      loadTasks();
    </script>
  </body>
</html>
