<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaskPilot - Today</title>
    <link rel="stylesheet" href="./css/today.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <div class="logo">
          <span class="logo-icon">üèÜ</span>
          <h1>TaskPilot</h1>
        </div>
        <nav>
          <a href="index.html">Plan</a>
          <a href="today.html" class="active">Today</a>
          <a href="tasks.html">Tasks</a>
          <a href="focus.html">Focus</a>
          <a href="settings.html">Settings</a>
        </nav>
      </header>

      <div id="dashboardContent"></div>
    </div>

    <script>
      let schedule = [];
      let completedTasks = new Set();
      let currentScheduleId = null; // Track schedule ID for updates

      async function loadSchedule() {
        try {
          const response = await fetch(`/schedules/today?_=${Date.now()}`);
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.schedule) {
              schedule = data.schedule;
              currentScheduleId = data.scheduleId; // Store schedule ID

              // Load completion status from tasks if stored
              completedTasks = new Set();
              schedule.forEach((task, index) => {
                if (task.completed) {
                  completedTasks.add(index);
                }
              });
            } else {
              schedule = []; // No schedule found or an empty schedule
              currentScheduleId = null;
            }
          } else if (response.status === 404) {
            schedule = []; // Explicitly handle 404 (no schedule for today)
            currentScheduleId = null;
          } else {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
        } catch (error) {
          console.error("Error fetching today's schedule:", error);
          alert("Failed to load today's schedule. Please try again later.");
          schedule = [];
          currentScheduleId = null;
        }

        // Fallback to localStorage for completion status if not in tasks
        const savedCompleted = localStorage.getItem("completedTasks");
        if (savedCompleted && completedTasks.size === 0) {
          completedTasks = new Set(JSON.parse(savedCompleted));
        }
        renderDashboard();
      }

      function getCurrentTask() {
        const now = new Date();
        const currentTime = now.getHours() * 60 + now.getMinutes();

        // Helper: parse "HH:MM AM/PM" into minutes since midnight
        const parseTimeToMinutes = (timeStr) => {
          if (!timeStr) return NaN;
          const parts = timeStr.trim().split(" ");
          const timeVal = parts[0] || timeStr.trim();
          const ampm = (parts[1] || "").toUpperCase();
          let [h, m] = timeVal.split(":").map(Number);
          if (Number.isNaN(h) || Number.isNaN(m)) return NaN;
          if (ampm === "PM" && h < 12) h += 12;
          if (ampm === "AM" && h === 12) h = 0; // midnight edge case
          return h * 60 + m;
        };

        let nextUpcomingTask = null; // first task whose start >= current time

        for (let i = 0; i < schedule.length; i++) {
          const task = schedule[i];
          const taskStartTimeInMinutes = parseTimeToMinutes(task.time);
          // Fallback duration: prefer durationMinutes, else parse numeric from duration like "60 min", else 60
          const parsedDuration =
            typeof task.durationMinutes === "number"
              ? task.durationMinutes
              : typeof task.duration === "string"
              ? parseInt(task.duration)
              : 60;
          const durationMinutes = Number.isFinite(parsedDuration)
            ? parsedDuration
            : 60;
          const taskEndTimeInMinutes = taskStartTimeInMinutes + durationMinutes;

          // Track the first upcoming task (start >= now) for boundary preference
          if (
            nextUpcomingTask === null &&
            taskStartTimeInMinutes >= currentTime
          ) {
            nextUpcomingTask = task;
          }

          // Active window: start <= now < end
          if (
            currentTime >= taskStartTimeInMinutes &&
            currentTime < taskEndTimeInMinutes
          ) {
            return task;
          }
        }

        // No active task: if we're exactly on a boundary or before the first task, prefer the future task
        if (nextUpcomingTask) {
          return nextUpcomingTask;
        }

        // Otherwise, the day is over: return the last task
        if (schedule.length > 0) {
          return schedule[schedule.length - 1];
        }

        // Default fallback when no schedule exists
        return {
          task: "No active task. Relax or plan your day!",
          time: "",
          duration: "",
          priority: "low",
        };
      }

      // Save updated schedule to backend
      async function saveScheduleToBackend() {
        if (!currentScheduleId) {
          console.warn("No schedule ID available");
          return;
        }

        try {
          const updatedSchedule = schedule.map((task, index) => ({
            ...task,
            completed: completedTasks.has(index),
          }));

          const response = await fetch(`/schedules/${currentScheduleId}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ plan: updatedSchedule }),
          });

          if (response.ok) {
            console.log("‚úÖ Schedule saved to backend");
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          console.error("Failed to save schedule:", error);
        }
      }

      async function toggleTask(index) {
        if (completedTasks.has(index)) {
          completedTasks.delete(index);
        } else {
          completedTasks.add(index);
        }
        localStorage.setItem(
          "completedTasks",
          JSON.stringify([...completedTasks])
        );
        renderDashboard();

        // Save to backend
        await saveScheduleToBackend();
      }

      function renderDashboard() {
        const content = document.getElementById("dashboardContent");

        if (schedule.length === 0) {
          content.innerHTML = `
                    <div class="card">
                        <div class="empty-state">
                            <div class="empty-state-icon">üìÖ</div>
                            <h2>No schedule for today</h2>
                            <p>Create your daily plan to get started</p>
                            <a href="index.html">Create Plan</a>
                        </div>
                    </div>
                `;
          return;
        }

        const currentTask = getCurrentTask();
        const completed = completedTasks.size;
        const total = schedule.length;
        const progress = Math.round((completed / total) * 100);

        content.innerHTML = `
                <div class="current-task">
                    <h2>Current Task</h2>
                    <div class="task-title">${currentTask.task}</div>
                    <div class="task-info">
                        <div class="task-meta">
                            <span>${currentTask.time}</span>
                            <span>${currentTask.duration}</span>
                            <span class="priority-badge priority-${
                              currentTask.priority
                            }">${currentTask.priority}</span>
                        </div>
                        <div class="task-actions">
                            <button class="btn-white" onclick="startFocusMode()">
                                <span>Focus Mode</span>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>Today's Tasks</h2>
                    <ul class="task-list">
                        ${schedule
                          .map(
                            (task, index) => `
                            <li class="task-item ${
                              completedTasks.has(index) ? "completed" : ""
                            }">
                                <div class="checkbox ${
                                  completedTasks.has(index) ? "checked" : ""
                                }" 
                                     onclick="toggleTask(${index})">
                                    ${completedTasks.has(index) ? "‚úì" : ""}
                                </div>
                                <div class="task-time">${task.time}</div>
                                <div class="task-text">${task.task}</div>
                                <div class="task-duration">${
                                  task.duration
                                }</div>
                            </li>
                        `
                          )
                          .join("")}
                    </ul>
                </div>

                <div class="card">
                    <h2>üóÇÔ∏è All Saved Schedules</h2>
                    <div id="allSchedules"></div>
                    <h3 style="margin-top:16px;">Today‚Äôs Versions</h3>
                    <div id="todaySchedules" class="today-schedules-list"></div>
                </div>

                <div class="card">
                    <h2>üìä Progress</h2>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress}%"></div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${completed}</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${total - completed}</div>
                            <div class="stat-label">Remaining</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 20px; margin-bottom: 15px; font-size: 18px;">Quick Actions</h3>
                    <div class="quick-actions">
                        <div class="quick-btn" onclick="window.location.href='focus.html'">
                            üéØ Start Focus Timer
                        </div>
                        <div class="quick-btn" onclick="exportCalendar()">
                            Export Calendar
                        </div>
                        <div class="quick-btn" onclick="window.location.href='index.html'">
                            Replan Day
                        </div>
                    </div>
                </div>
            `;

        // After rendering base UI, fetch and render all schedules
        fetchAllSchedules();
        fetchTodaySchedulesList();
      }

      async function fetchAllSchedules() {
        try {
          const res = await fetch(`/schedules?_=${Date.now()}`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          if (!data.success)
            throw new Error(data.error || "Failed to load schedules");

          const container = document.getElementById("allSchedules");
          if (!data.schedules || data.schedules.length === 0) {
            container.innerHTML = `<div class="empty-state"><p>No saved schedules yet.</p></div>`;
            return;
          }

          const items = data.schedules
            .map((s) => {
              const preview = (s.plan || [])
                .slice(0, 3)
                .map((it) => `${it.time} ${it.task}`)
                .join(" ‚Ä¢ ");
              const savedTime = (function f() {
                try {
                  const d = new Date(s.created_at || s.date);
                  return d.toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit",
                  });
                } catch (_) {
                  return "";
                }
              })();
              const promptText = s.prompt ? s.prompt : preview;
              const encodedPlan = encodeURIComponent(JSON.stringify(s.plan));
              return `
                <div class="today-schedule-item" title="${s.date} ‚Ä¢ ${promptText}" data-plan="${encodedPlan}" onclick="setActiveSchedule(this.getAttribute('data-plan'))">
                  <span class="dot"></span>
                  <span class="line-clamp">${s.date} ‚Ä¢ ${promptText}</span>
                  <span class="save-time">${savedTime}</span>
                  <button class="btn-white" onclick="event.stopPropagation(); deleteSchedule(${s.id});">Delete</button>
                </div>
              `;
            })
            .join("");

          container.innerHTML = items;
        } catch (e) {
          const container = document.getElementById("allSchedules");
          container.innerHTML = `<div class="empty-state"><p>Error loading schedules: ${e.message}</p></div>`;
        }
      }

      function formatTime(ts) {
        try {
          if (
            typeof ts === "string" &&
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(ts)
          ) {
            // Treat as LOCAL time string now stored by the server
            const isoLocal = ts.replace(" ", "T");
            return new Date(isoLocal).toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });
          }
          if (typeof ts === "number") {
            return new Date(ts).toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            });
          }
          return new Date(ts).toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          });
        } catch (e) {
          return "";
        }
      }

      async function fetchTodaySchedulesList() {
        try {
          const now = new Date();
          const yyyy = now.getFullYear();
          const mm = String(now.getMonth() + 1).padStart(2, "0");
          const dd = String(now.getDate()).padStart(2, "0");
          const today = `${yyyy}-${mm}-${dd}`;
          const res = await fetch(
            `/schedules/by-date?date=${today}&_=${Date.now()}`
          );
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          if (!data.success)
            throw new Error(data.error || "Failed to load today schedules");

          const container = document.getElementById("todaySchedules");
          if (!data.schedules || data.schedules.length === 0) {
            container.innerHTML = `<div class="empty-state"><p>No versions saved today.</p></div>`;
            return;
          }

          container.innerHTML = data.schedules
            .map((s, idx) => {
              const preview = (s.plan || [])
                .map((it) => `${it.time} ${it.task}`)
                .join(" ‚Ä¢ ");
              const promptText = s.prompt ? s.prompt : preview;
              const savedTime = (function f() {
                try {
                  const d = new Date(s.created_at || s.date);
                  return d.toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit",
                  });
                } catch (_) {
                  return "";
                }
              })();
              const encodedPlan = encodeURIComponent(JSON.stringify(s.plan));
              return `
              <div class="today-schedule-item" data-plan="${encodedPlan}" onclick="setActiveSchedule(this.getAttribute('data-plan'))" title="${promptText}">
                <span class="dot"></span>
                <span class="line-clamp">${promptText}</span>
                <span class="save-time">${savedTime}</span>
                <button class="btn-white" onclick="event.stopPropagation(); deleteSchedule(${s.id});">Delete</button>
              </div>
            `;
            })
            .join("");
        } catch (e) {
          const container = document.getElementById("todaySchedules");
          container.innerHTML = `<div class="empty-state"><p>Error: ${e.message}</p></div>`;
        }
      }

      // Switch active schedule for today and re-render
      function setActiveSchedule(planArg) {
        try {
          console.log("setActiveSchedule called with:", planArg);
          let nextSchedule = planArg;
          if (typeof planArg === "string") {
            // Decode from encodeURIComponent(JSON.stringify(...))
            const decoded = decodeURIComponent(planArg);
            console.log("Decoded:", decoded);
            nextSchedule = JSON.parse(decoded);
          }
          console.log("Parsed schedule:", nextSchedule);
          schedule = Array.isArray(nextSchedule) ? nextSchedule : [];
          console.log("New schedule set:", schedule);
          // reset completed state when switching
          completedTasks = new Set();
          localStorage.removeItem("completedTasks");
          renderDashboard();
        } catch (e) {
          console.error("Error in setActiveSchedule:", e);
          alert("Failed to switch schedule: " + e.message);
        }
      }

      async function deleteSchedule(id) {
        try {
          const res = await fetch(`/schedules/${id}`, { method: "DELETE" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          // Refresh lists
          fetchAllSchedules();
          fetchTodaySchedulesList();
        } catch (e) {
          alert(`Failed to delete schedule: ${e.message}`);
        }
      }

      function startFocusMode() {
        alert("Focus Mode is not yet implemented.");
      }

      function exportCalendar() {
        if (!schedule || schedule.length === 0) {
          alert("No schedule to export. Please generate a plan first.");
          return;
        }

        try {
          // Create iCalendar format
          const now = new Date();
          const today = now.toISOString().split("T")[0].replace(/-/g, "");
          const timestamp =
            now.toISOString().replace(/[-:]/g, "").split(".")[0] + "Z";

          let icsContent = [
            "BEGIN:VCALENDAR",
            "VERSION:2.0",
            "PRODID:-//TaskPilot//Schedule Export//EN",
            "CALSCALE:GREGORIAN",
            "METHOD:PUBLISH",
            "X-WR-CALNAME:TaskPilot Schedule",
            "X-WR-TIMEZONE:UTC",
          ];

          // Convert each task to a calendar event
          schedule.forEach((task, index) => {
            const taskTime = task.time || "09:00 AM";
            const taskDuration = task.durationMinutes || 60;

            // Parse time to get start datetime
            const [timeVal, ampm] = taskTime.split(" ");
            let [hours, minutes] = timeVal.split(":").map(Number);
            if (ampm === "PM" && hours < 12) hours += 12;
            if (ampm === "AM" && hours === 12) hours = 0;

            const startDate = new Date(now);
            startDate.setHours(hours, minutes || 0, 0, 0);

            const endDate = new Date(startDate);
            endDate.setMinutes(endDate.getMinutes() + taskDuration);

            // Format dates for iCalendar (YYYYMMDDTHHMMSS)
            const formatDateTime = (date) => {
              const pad = (n) => String(n).padStart(2, "0");
              return (
                date.getFullYear() +
                pad(date.getMonth() + 1) +
                pad(date.getDate()) +
                "T" +
                pad(date.getHours()) +
                pad(date.getMinutes()) +
                pad(date.getSeconds())
              );
            };

            const dtStart = formatDateTime(startDate);
            const dtEnd = formatDateTime(endDate);

            // Clean task description for calendar
            const taskDescription = task.task
              .replace(/\n/g, "\\n")
              .replace(/,/g, "\\,");
            const priority = task.priority || "medium";
            const priorityMap = { high: 1, medium: 5, low: 9 };

            icsContent.push(
              "BEGIN:VEVENT",
              `UID:taskpilot-${today}-${index}@taskpilot.app`,
              `DTSTAMP:${timestamp}`,
              `DTSTART:${dtStart}`,
              `DTEND:${dtEnd}`,
              `SUMMARY:${taskDescription}`,
              `DESCRIPTION:Priority: ${priority}\\nDuration: ${taskDuration} minutes`,
              `PRIORITY:${priorityMap[priority]}`,
              `STATUS:CONFIRMED`,
              `SEQUENCE:0`,
              "END:VEVENT"
            );
          });

          icsContent.push("END:VCALENDAR");

          // Create downloadable file
          const icsBlob = new Blob([icsContent.join("\r\n")], {
            type: "text/calendar;charset=utf-8",
          });

          const downloadLink = document.createElement("a");
          downloadLink.href = URL.createObjectURL(icsBlob);
          downloadLink.download = `taskpilot-schedule-${today}.ics`;

          // Trigger download
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);

          // Clean up
          URL.revokeObjectURL(downloadLink.href);

          alert(
            "‚úÖ Calendar exported! Import the .ics file into Google Calendar, Outlook, or Apple Calendar."
          );
        } catch (error) {
          console.error("Export error:", error);
          alert("‚ùå Failed to export calendar. Please try again.");
        }
      }

      loadSchedule();
    </script>
  </body>
</html>
